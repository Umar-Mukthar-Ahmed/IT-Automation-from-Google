What are the two main parts of an operating system?
* system and user space 
* kernel and user space
* core and system resources
* hard drive and kernel 

<br>

What are some of the common Linux distributions? Select all that apply.

* Red Hat
* Ubuntu
* Kernel
* Debian

You run the command python --version and see the output Python 3.9.9. Which version of Python is your computer running?

* Python
* Python 3
* Python 2
* Python Unlimited

Question 4
Which of the following statements best describes an interpreted language?

* Interpreted languages are faster languages but more prone to errors. 

* Interpreted languages are languages used mainly for system programming. 

* Interpreted languages are languages that are converted into machine code before execution.

* An interpreted language is a programming language that is executed line by line by an interpreter.

<br>

Question 5
You are a software developer working on a new project to create a web application. You are using a popular IDE called PyCharm to write your code. PyCharm provides a variety of features to help you develop your code, including a code editor, a debugger, and a terminal. Which of the following statements best describes the purpose of an IDE?

* An IDE is a tool that helps software developers deploy their code to production.

* An IDE is a tool that helps software developers write, debug, and test their code.

* An IDE is a tool that helps software developers test their code for bugs.* 

* An IDE is a tool that helps software developers write their code more quickly and efficiently.

<br>

You are an IT automation engineer working on an automation script. You are using a variety of Python libraries in your script. You are also using a variety of different versions of these libraries. You are working on a team with other engineers, and you are finding it difficult to manage the different versions of Python libraries that everyone is using. You are worried that this will lead to conflicts and errors when you try to run your code. You have heard about virtual environments, and you are wondering if they might be a solution to your problem. Which of the following statements best describes how virtual environments can help you solve your problem?

* Virtual environments allow you to deploy your code to production more easily.

* Virtual environments allow you to debug your code more efficiently.

* Virtual environments allow you to install libraries in a way that is isolated from your system Python environment.

* Virtual environments allow you to test different versions of Python on your system.

<br>

Question 7
A company hires a lot of employees over a short period of time. Previously, the company completed onboarding tasks such as creating a user account, a mailbox, and a home folder, and setting up the appropriate permissions to control access to various systems and resources for each new employee manually. Because of this increase in new hires it would take a lot of time to onboard all of these new employees. What is the solution to this problem?

* Automation

* Virtual Environments

* Java

* Onboarding templates

<br>

Question 8
Automation systems can sometimes experience failures, disrupting operations and causing data loss. What strategies can be implemented to ensure timely notification and prompt remediation in case of automation system failures?

* Rewrite your automation script on a regular basis. 

* Complete the tasks that are automated manually from time to time and compare the results against automated tasks. 

* Test the automation script once before you deploy it. 

* Establish a monitoring system to detect and notify relevant personnel of automation system failures.

<br>

You want to create a Python script that automates system monitoring tasks on your computer. What Python module should you use in your script?

* matplotlib

* pandas

* numpy

* psutil

<br>

Which formula would you use to determine if a task would save labor time and should be automated?

* amount_of_times_done < (time_to_automate * time_to_perform)

* time_to_perform < (time_to_automate * amount_of_times_done)

* time_to_automate < (time_to_perform * amount_of_times_done)

* time_to_automate > (time_to_perform * amount_of_times_done)
